#!/bin/bash

set -e

DIR="$(CDPATH= cd -- "$(dirname -- "$0")/.." && pwd -P)"
PKI="$DIR/example-setup/pki-ids"
INPUT="$DIR/example-setup/metadata-raw"
OUTPUT="$DIR/example-setup/metadata-signed-ids"

print_usage() {
  printf 'Usage: ./sign-ids-metadata -f <"json"|"cbor"> [-p <pki-dir>] [-i <input-dir>] [-o <output-dir] [-h]\n'
}

while getopts 'f:p:i:o:h' flag; do
  case "${flag}" in
    f)
      if [ "${OPTARG}" != "cbor" ] && [ "${OPTARG}" != "json" ]; then
        printf "Error: Only 'json' or 'cbor' supported, not ${OPTARG}"
        print_usage
        exit 1
      fi
      FORMAT="${OPTARG}"
	;;
    p)
        PKI="${OPTARG}"
        ;;
    i)
        INPUT="${OPTARG}"
        ;;
    o)
        OUTPUT="${OPTARG}"
        ;;
    h)
        print_usage
        exit 1
        ;;
    *) print_usage
       exit 1 ;;
  esac
done

if [ -z "$FORMAT" ]; then
  printf "Error: format must be specified"
  print_usage
  exit 1
fi   

if [ ! -d "$PKI" ]; then
  echo "PKI Directory $PKI does not exist. Did you run 'generate-pki'? Abort.."
  exit 1
fi

if [ ! -d "$INPUT" ]; then
  echo "Input Directory $INPUT does not exist. Abort.."
  exit 1
fi

echo "Using $FORMAT as format"
echo "Using $PKI as pki directory"
echo "Using $INPUT as input directory"
echo "Using $OUTPUT as output directory"

SIG="signing-tool"
CONV="converter"

KEY_DEV_A=$PKI/developer_A/developer_A-key.pem
CHAIN_DEV_A=$PKI/users/developer_A.pem,$PKI/ca/user_sub_ca.pem,$PKI/ca/ca.pem

KEY_EVA_A=$PKI/evaluator_A/evaluator_A-key.pem
CHAIN_EVA_A=$PKI/users/evaluator_A.pem,$PKI/ca/user_sub_ca.pem,$PKI/ca/ca.pem

KEY_EVA_B=$PKI/evaluator_B/evaluator_B-key.pem
CHAIN_EVA_B=$PKI/users/evaluator_B.pem,$PKI/ca/user_sub_ca.pem,$PKI/ca/ca.pem

KEY_CERT_A=$PKI/certifier_A/certifier_A-key.pem
CHAIN_CERT_A=$PKI/users/certifier_A.pem,$PKI/ca/user_sub_ca.pem,$PKI/ca/ca.pem

KEY_CERT_B=$PKI/certifier_B/certifier_B-key.pem
CHAIN_CERT_B=$PKI/users/certifier_B.pem,$PKI/ca/user_sub_ca.pem,$PKI/ca/ca.pem

KEY_OP_A=$PKI/operator_A/operator_A-key.pem
CHAIN_OP_A=$PKI/users/operator_A.pem,$PKI/ca/user_sub_ca.pem,$PKI/ca/ca.pem

# Clean start
rm -rf $OUTPUT
mkdir -p $OUTPUT

# If CBOR format is specified, the json manifests must be converted first
if [ "$FORMAT" == "cbor" ]; then
  echo "Converting raw json metadata to cbor metadata"
  for path in $IN/*; do
    # Extract filename and extension
    IN=$(basename ${path})
    EXT=${IN##*.}
    # Only convert JSON files
    [ $EXT == "json" ] || continue
    # Write them to the same folder as the input files
    OUT=${IN%.*}.$FORMAT
    # Convert JSON to CBOR using the converter-tool
    $CONV -in $INPUT/$IN -out $INPUT/$OUT -inform json -outform cbor
  done
fi

echo "Signing $FORMAT metadata"

$SIG -in $INPUT/rtm.manifest.$FORMAT         -out $OUTPUT/rtm.manifest.$FORMAT         -keys $KEY_DEV_A,$KEY_EVA_A,$KEY_CERT_A -x5cs $CHAIN_DEV_A:$CHAIN_EVA_A:$CHAIN_CERT_A
$SIG -in $INPUT/os.manifest.$FORMAT          -out $OUTPUT/os.manifest.$FORMAT          -keys $KEY_DEV_A,$KEY_EVA_A,$KEY_CERT_A -x5cs $CHAIN_DEV_A:$CHAIN_EVA_A:$CHAIN_CERT_A
$SIG -in $INPUT/company.description.$FORMAT  -out $OUTPUT/company.description.$FORMAT  -keys $KEY_OP_A,$KEY_EVA_B,$KEY_CERT_B -x5cs $CHAIN_OP_A:$CHAIN_EVA_B:$CHAIN_CERT_B

$SIG -in $INPUT/device.description.$FORMAT   -out $OUTPUT/device.description.$FORMAT   -keys $KEY_OP_A -x5cs $CHAIN_OP_A
$SIG -in $INPUT/ak.certparams.$FORMAT        -out $OUTPUT/ak.certparams.$FORMAT        -keys $KEY_OP_A -x5cs $CHAIN_OP_A
$SIG -in $INPUT/tlskey.certparams.$FORMAT    -out $OUTPUT/tlskey.certparams.$FORMAT    -keys $KEY_OP_A -x5cs $CHAIN_OP_A
